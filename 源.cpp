#define _CRT_SECURE_NO_WARNINGS
//----------------06静态 常量 友元-------------------
// *01.静态成员
// 02.单例模式 //特定环境下使用
// 03.友元
// 04.常量成员


//---------------------01----------------------
//1.静态成员 static   分为静态数据成员 与静态函数成员
//    01.类中的静态数据成员，所有对象都共享该数据，只有一份内存
//    02.类中的静态数据成员，必须要在类外进行初始化，因为他属于类
//    03.类中的静态数据成员，可以在类中被重新赋值，也可以被普通函数访问，如果有着公有属性，则在类外也可以访问

//-------------------02-------------------------------
//可以保证系统中，相关的应用该模式的类只有一个实例对象
//单例模式可以通过引用或者指针实现

//------------------03-----------------------------
//类的特性之一就是封装
//友元是c++为用户提供的打破封装的手段
// 友元分为友元函数和友元类
// 单方向：b是a的朋友，b可以访问a的数据，但是a不能访问b的数据
// 不传递：a是b的朋友,b是c的朋友,但是a与c没有朋友关系
// 
// 
// //----------友元函数---------------
// 1.是一个函数
// 友元函数不是类的成员，通过类是无法访问到的，
// 但是在这个函数中是有权通过访问类来访访问类中的所有成员的
// 2.友元函数，无论声明在类中的任何访问属性下都可以，不影响他的调用和访问
// ------------------友元类--------------
//1.是一个单独类
// 只不过和友元函数一样，在类内声明了一个友元类
// 在这个友元类中同样也可以访问该类中的所有成员

//---------------04---------------------
//常量成员，值的是在c++类中声明对象的成员时可以加上的const关键字，这样声明的成员叫常量成员
// 常量成员分为常量数据成员与常量函数成员
// 常量数据成员需要使用初始化成员列表初始化
//常量函数成员则无法修改类中的普通数据成员（静态数据可以）
//


#include<iostream>
#include<string>
using namespace std;

//------------------------------01--------------------------
//class text
//{
//public:
//	int a;
//	static int aa;
//public:
//	static void fun1()
//	{
//		//定义
//	}
//	static void fun2();//类内声明
//};
////类外初始化：
//int text::aa = 666;//text::代表着归属地  int代表着aa的类型 
////int text::a = 123;//非静态成员不能再类外初始化



//void text::fun2()//类外定义//类内定义的函数时默认内联的
//{
//	/*
//	* 1.不属于对象，属于类，不能访问普通数据成员和函数成员，作用域为全局
//	* 2.访问与静态的数据成员一致
//	* 3.可以使用局部变量
//	*/
//	int abc = 666;
//	cout << abc << endl;
//	aa = 234;
//}


//-----------------02-----------------------
////引用方式
//class node
//{
// int a;//这种叫做类内声明――实际上是没有的，告诉程序你要做但是还没做
// int a=0;//叫做类内初始化（定义了）
// 而像 static node a;静态数据成员的写法就必须在类内声明，在类外初始化――定义
// 而像static void fun2(){   // 定义   }   静态函数可以在类内定义类内声明，也可以在类外声明
// 
// 
//	//构造和拷贝构造放在私有下
//	node(){}//无参构造
//	node(node const& n){}//拷贝函数{}中可以放入想要初始化的对象
//	static node n;//单例独苗//一般是不支持在类的内部定义一个对象，n是成员也是对象，且一般放在类外面，
//	//但静态可以静态定义的一个成员是自身类型的对象
//	//node n;报错
//
//	//由于我将函数和值全放在私有下，导致无法访问，但是可以获取这个静态单例
//public:
//	static node & getnode()
//	{
//		return n;
//	}
//
//};
//
//node node::n;//类外初始化

////--------指针方式----------
//class node
//{
//	node() {};
//	node(node const& n ){};
//	static node* nnode;
//public:
//	static node*  & getnode()
//	{
//		return nnode;
//	}
//};
//node* node::nnode=new node;

////------------03友元函数-----------------------
//class B
//{
//
//	int b = 10;
//	void fun()
//	{
//		cout << b << endl;
//	}
//	//友元关键字
//	//friend void  laowang()//类内定义
//	//{
//	//	fun;
//	//}
//
//	//类外实现
//	//由于友元不是类内的一部分，所以不能在类内定义，只能做声明
//	//由于友元不是类内的一部分,所以不受 访问属性 公有私有的约束，但是一个更根本的问题是老王开始就不是类内的成员，本就找不到他
//	//就像 类是一家公司，老王不是公司的人，只是公司的朋友，所以对公司所以成员的查找都找不到老王，无论是公有的人，还是私有的人都没有
//	friend void laowang(B & b);
//
//
//};
//
//void laowang(B & b)//可以这样理解老王是B的朋友，B就允许老王建立一个有关B内部成员的对象，通过对对象的处理改变B的东西
//{
//	//友元函数打破封装
//	b.fun();
//	b.b = 999;
//	cout << b.b << endl;
//}

////--------03友元类--------------
//class C;//防止程序执行到friend class c处， c还没创立出现报错
//class D
//{
//	friend class C;
//	int c = 100;
//};
//class C//友元类
//{
//public:
//	int a;
//	static int b ;
//	void laowang(D& d)//&节省了一个自身的拷贝，将自身传过去
//	{
//		cout << d.c << endl;
//	}
//};

//---------------04-----------------------
class E
{
public:
	//const int e = 666;//第一种初始化，有些版本不支持
	//第二种初始化
	const int e;
	//E() :e(666){}//构造函数的后面加上单冒号：，就是初始化成员列表其优先级高于函数体，
	//在函数体执行前会进行初始化，上次初始化的是引用成员，这次是常量成员

	int eee;
	E():e(6),eee(1){}
	void E_const(const int val) const//在后面加上的保护的是 普通数据成员(eee,e)，
		//在参数列表 里面加的 const 保护的是形参(val),保护对象不同
	{
		//因为有些成员数据是不需要传参，可以使用this访问修改的（访问不了静态的，没有权限，只能访问普通成员）,那怎么保护它呢？在后面加上const进行保护，只读属性
		int ee;
		ee = 6666;//局部变量不被约束，临时的处于栈区的，而静态的处于全局区
		cout << eee << endl;
	}
};


int main()
{
	//---------------------04常量成员-----------------
	const E e;//常量对象  必须初始化   所有普通的数据都不能修改
	//无法访问普通函数  只能访问常量函数（一定不会修改普通数据的），
	//但是普通函数可以修改普通数据的，所以普通函数也被禁了



	//-----------------03友元函数---------------
	//B b1;
	//laowang(b1);
	//---------03友元类--------------
	//C c;
	//D d;
    //c.laowang(d);
	////C::a = 100;//非静态成员(a)引用时必须与特定的对象(c)相对（.）
	//c.a = 100;
	//c.b = 10;
	//C::b = 100;
	//不继承,a是b的朋友，a是c的父亲,但c与b不是朋友
	//
	//但是友元会打乱结构就像goto一样

	//------------02----------------------------------------------------------------------------------------
	//node& n1 = node::getnode();//node& 相当于一种引用类型（可以理解为取别名）
	//node& n2 = node::getnode();//n1与n2的地址相同，引用获取一份的独苗，但是由于引用本就是本身，n1与n2相当于引用的别名,所以其实地址还是相同的
	//cout << &n1 << endl;
	//cout << &n2 << endl;
	// 
	//node* p1 = node::getnode();
	//node* p2 = node::getnode();
	//node* p3 = node::getnode();
	//cout << p1 << endl;
	//cout << p2 << endl;

	//-------------------01-------------------------
	//text t1;
	//t1.a = 1;
	//t1.aa = 11;
	//text t2;
	//t2.a = 2;
	//t2.aa= 22;//因为公用一块内存，这也能够可以一改全改，可以用于每个关卡的重置
	//text::aa = 33;//仅公有的情况支持
	////cout << "t1.a:" << t1.a << endl;//普通成员
	////cout << "t1.a:" << t1.aa << endl;//静态成员，结果为22，因为类内公用一块内存
	////cout << "&t1.a:" << &t1.a << endl;
	////cout << "t1.a:" << t2.a << endl;
	////cout << "t1.a:" << t2.aa << endl;
	////cout << "&t2.a:" << &t2.a << endl;//结果为
	//text::fun1();
	//text::fun2();
	//------------------------01-------------------
	return 0;
}

